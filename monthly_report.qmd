---
title: ""
bibliography: grateful-refs.bib
format: 
  closeread-html:
    backgroundcolor: white
    mainfont: serif
    fontsize: "1.8rem"
    cr-style:
      section-background-color: white  
      narrative-font-family: serif
      narrative-text-color-sidebar: "#3E3E40"  
      narrative-background-color-sidebar: white 
      narrative-background-color-overlay: white
      narrative-text-color-overlay: "#3E3E40" 
      narrative-border-radius: "10px"  
      narrative-sidebar-width: "1fr"
      narrative-overlay-max-width: "60%"  
      narrative-outer-margin: "10px"  
      narrative-font-size: "1.2rem" 
    cr-section:
      layout: "sidebar-left"
    theme: custom.scss
  gfm: 
    output-file: README.md
format-links: false
execute:
  echo: false
  cache: true
---

```{r notes}
#| include: false
# things to add
# numbers of obs by category
# averages by category
# map showing observations over time animation
# lollipop summer vs winter shops - maybe summarize by category
# highest velocity based off of different time periods
start_date <- lubridate::ymd("2026-01-31")
```

# Monthly indoorCO2map.com summary `r start_date |> lubridate::month(label = TRUE, abbr = FALSE)` `r start_date |> lubridate::year()`

There is a well documented relationship between indoor levels of CO~2~ and the amount of ventilation in indoor environments. Buildings with high indoor levels of CO~2~ have poor ventilation and are therefore more likely to be vectors of airborne diseases (like COVID-19, Measles, and Flu) and to trap indoor pollutants.

Measuring CO~2~ inside is a really cheap way of measuring the air quality in indoor environments. When we breathe, we exhale  CO~2~ and it gets trapped inside the room we are in. If the building has good ventilation it will leave quickly. If it has bad ventilation, it stays in the room and builds up.

If there is bad ventilation, then smoke from cooking can build up and that's bad for you. Same thing for VOCs from perfumes, as well as gas leaks, radon, and mold spores. At high concentrations in artificial environments, they contribute to all sorts of things: cancer, Alzheimer's, Parkinson's, childhood asthma, childhood lung problems, and heart conditions.
Bad ventilation also contributes to a much higher risk of respiratory infections. If someone who is sick breathes in a badly ventilated room, the infectious aerosols will float around in the room until someone breathes them in. In a well ventilated space, they are dispersed very quickly and the risk of infection is much lower. Having an open window in a classroom (or having an air filter), for instance, reduces school absences significantly.

CO~2~ levels outside are typically around 420 parts per million (ppm), so if we measure the CO~2~ in a room and it is higher than that, you know its not ventilating much.
Anywhere from 400 - 600 ppm are considered well ventilated. Every indoor environment is going to trap some CO~2~ and that's okay. Levels between 600 ppm and 1000 ppm may need some improvement. Anything above 1000 ppm is generally considered bad and should certainly be improved in some manner.

[Indoor CO2-Map](https://indoorco2map.com) is a community science project to monitor indoor CO~2~ levels in non-residential buildings and transit systems around the world. Since April 2024 volunteers have brought CO~2~ monitors into cafes, shops, schools, trains, and all sorts of other places to monitor CO~2~ levels in them and upload them to a public database. 

The following is a monthly summary of how this project is going.

```{r libraries}
#| warning: false
#| message: false
#| include: false 
#| cache: false
source(here::here("functions/functions.R"))
```

```{r inputs}
#| warning: false
#| message: false
#| include: false
library(duckplyr)
buildings_wide_df <- autocruller::ac_get_co2("web") 
# saveRDS(buildings_wide_df, here::here("buildings_wide_df.rds"))
# buildings_wide_df <- readRDS(here::here("buildings_wide_df.rds"))

buildings_wide_df <- sf::st_join(buildings_wide_df, world_sf)

buildings_wide_df <- 
  buildings_wide_df |> 
  dplyr::rowwise() |>
    dplyr::mutate(
      best_country_name = name_ciawf %||% 
        brk_name %||%
        name_en %||%
        admin %||%
        name %||%
        countryname
    ) 

buildings_wide_df_short <-
  buildings_wide_df |>
    # sf::st_drop_geometry() |>
    filter_to_month(start_date) |>
    dplyr::mutate(type = "building")

transit_long_df <- autocruller::ac_get_co2("transit") 
# saveRDS(transit_long_df, here::here("transit_long_df.rds"))
# transit_long_df <- readRDS(here::here("transit_long_df.rds"))

```

```{r}
#| include: false
#| warning: false
#| message: false
transit_long_df <- join_transit_osm(transit_long_df)

```

```{r}
#| warning: false
#| message: false
#| include: false
transit_long_df <- sf::st_join(transit_long_df, world_sf)

transit_long_df <- 
  transit_long_df |> 
  dplyr::rowwise() |>
    dplyr::mutate(
      best_country_name = name_ciawf %||% 
        brk_name %||%
        name_en %||%
        admin %||%
        sovereignt %||%
        name.y
    ) 
```

```{r}
#| warning: false
#| message: false
#| include: false
transit_long_df_short <- 
transit_long_df |> 
    filter_to_month(start_date) |> 
        dplyr::mutate(type = "transit")
```


```{r}
#| warning: false
#| message: false
#| include: false
common_building_types <- buildings_wide_df |> 
  dplyr::group_by(osmtag) |> 
  dplyr::count() |> 
  dplyr::filter(
    n > quantile(n, 0.98, na.rm = TRUE) & osmtag != ""
    )
```

```{r}
#| warning: false
#| message: false
#| include: false 
# list new countries
new_countries_sentence <- form_new_countries_sentence(buildings_wide_df, buildings_wide_df_short, extra_country = "Taiwan")

```

```{r geocodebuildings}
#| eval: false
#| include: false
buildings_wide_df_short_geo <- geocode_buildings_or_transit(buildings_wide_df_short)

# saveRDS(buildings_wide_df_short_geo, here::here("data/derivative/buildings_wide_df_short_geo.rds"))
```

```{r geocodetransit}
#| eval: false
#| include: false

transit_long_df_short_geo <- geocode_buildings_or_transit(transit_long_df_short)
  
# saveRDS(transit_long_df_short_geo, here::here("data/derivative/transit_long_df_short_geo.rds"))

```

```{r}
#| include: false
#| eval: false

buildings_wide_df_short_geo <- 
  # buildings_wide_df_short_geo |> 
  readRDS(here::here("data/derivative/buildings_wide_df_short_geo.rds")) |> 
  dplyr::rowwise() |> 
  dplyr::mutate(
    location_description = glue::glue("{city %||% county %||% province %||% state %||% town %||% municipality %||% region %||% borough %||% suburb %||% neighbourhood %||% city_district}, {country}")
      ) |> 
    sf::st_as_sf(coords = c("X", "Y"), crs = sf::st_crs(buildings_wide_df_short))

buildings_wide_df_short <- sf::st_join(
  buildings_wide_df_short,
  buildings_wide_df_short_geo,
  left = TRUE,
  largest = TRUE
) |> dplyr::ungroup()

```

```{r}
#| warning: false
#| message: false
#| include: false 

buildings_long_df <- autocruller::ac_unnest_longer(buildings_wide_df_short)
```

```{r transitgeo}
#| eval: false
#| include: false
transit_long_df_short_geo <- 
  # transit_long_df_short_geo |> 
  readRDS(here::here("data/derivative/transit_long_df_short_geo.rds")) |> 
  dplyr::rowwise() |> 
  dplyr::mutate(
    location_description = glue::glue("{city %||% county %||%  state %||% town %||% municipality %||% region %||% borough %||% suburb %||% neighbourhood %||% city_district}, {country}")
      ) |> 
     sf::st_as_sf(coords = c("X", "Y"), crs = sf::st_crs(transit_long_df_short))

transit_long_df_short <- transit_long_df_short |> 
  dplyr::mutate(osm_id_line = as.integer(osm_id_line))

# this doesn't work
# transit_long_df_short <- dplyr::left_join(
#   transit_long_df_short,
#   transit_long_df_short_geo,
#   by = dplyr::join_by(osm_id_line == place_id)
# )

transit_long_df_short <- sf::st_join(
  transit_long_df_short,
  transit_long_df_short_geo,
  left = TRUE,
  largest = TRUE
) |> dplyr::ungroup()
```

```{r}
#| warning: false
#| message: false
#| include: false 
transit_long_df_short <- transit_long_df_short |> 
  dplyr::mutate(osm_id_line = as.integer(osm_id_line))
```


## Buildings

```{r animbuildings}
#| warning: false
#| message: false
#| out.width: "100%"
library(gganimate)
library(rnaturalearth)
library(rnaturalearthhires)
countries_sf <- rnaturalearth::ne_countries(scale = 50L)
bbox_buildings <- sf::st_bbox(buildings_wide_df_short)
anim <-
  buildings_wide_df_short |>
  dplyr::mutate(day = as.Date(date)) |>
  ggplot2::ggplot() +
  ggplot2::geom_sf(data = countries_sf, fill = "white") +
  ggplot2::geom_sf(aes(colour = ppmavg), size = 2) +
  gganimate::transition_time(day) +
  gganimate::enter_grow() +
  gganimate::shadow_mark(past = TRUE, future = FALSE, alpha = 0.6 
  # color = "grey"
  ) +
  xlim(bbox_buildings[1] - 1, bbox_buildings[3] + 1) +
  ylim(bbox_buildings[2] - 1, bbox_buildings[4] + 1) +
  scale_color_viridis_c(
    name = "Mean CO2 ppm",
    breaks = c(420, 600, 800, 1200, 2000, 4000),
    transform = "log2",
    option = "turbo"
  ) +
  theme(
    plot.background = ggplot2::element_rect(fill = NA, colour = NA),
    plot.title = ggplot2::element_text(size = ggplot2::rel(1.5)),
    legend.background = ggplot2::element_rect(fill = NA, colour = NA),
    legend.key = ggplot2::element_rect(fill = NA, colour = NA),
    legend.key.width = unit(0.6, "lines"),
    legend.key.height = unit(1, "lines"),
    strip.background = ggplot2::element_rect(fill = "#cbd6dfff", colour = NA),
    panel.background = ggplot2::element_rect(fill = "#cbd6dfff", colour = NA),
    panel.border = ggplot2::element_rect(
      fill = NA,
      colour = "black",
      linewidth = 0.5
    ),
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank(),
    axis.ticks = ggplot2::element_line(colour = "black", linewidth = 0.25),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14)
  ) +
  ggtitle("{frame_time}")

animate(
  anim,
  nframes = 32,
  driver = 'png',
  # quality = 40,
  # nframes = 260,
  fps = 5
) |> magick::image_trim()
# anim_save(here::here("data/derivative/animation.gif"), anim2)

```

:::{.cr-section}

```{r mostmeasured}
#| echo: false
#| warning: false
#| message: false
#| include: false 
most_measured <- 
buildings_wide_df_short |> 
  summarise_most_measured_buildings()

mean_vals <- buildings_wide_df_short |>
  sf::st_drop_geometry() |> 
    dplyr::filter(
      ppmavg >= 410
    ) 
  
```

```{r countriescount}
#| warning: false
#| message: false
#| include: false 
countries_count <- 
buildings_wide_df_short |> 
    dplyr::select(uid = obs_number, best_country_name, type) |> 
    sf::st_drop_geometry() 

# not yet done. need to give transit data a country col
countries_count_transit <- 
    transit_long_df_short |> 
    dplyr::group_by(uid, best_country_name, type) |> 
    dplyr::count() |> 
    dplyr::select(-n) |> 
    # dplyr::summarise(n = dplyr::n_distinct(uid)) |> 
    # tidyr::drop_na() |> 
    sf::st_drop_geometry()

countries_count <- 
  dplyr::bind_rows(countries_count, countries_count_transit) 
  # dplyr::left_join(iso_3166_a2, by = dplyr::join_by(country_code == code))  
  

# countries_count <- countries_count[order(countries_count$n, decreasing = TRUE),] |> 
#   tidyr::drop_na()
countries_count <- 
    countries_count |>
      # dplyr::mutate(
      #   type = forcats::fct_relevel(type, "building", "transit"), #|> forcats::fct_rev()
      #   # best_country_name = forcats::fct_infreq(best_country_name) |> forcats::fct_rev()
        
      #   ) |> 
      dplyr::group_by(best_country_name, type) |> 
      dplyr::count() 



countries_labels <- 
  countries_count |> 
  tidyr::pivot_wider(names_from = type, values_from = n) |>
  dplyr::mutate(
    building = tidyr::replace_na(building, 0),
    transit = sum(transit, building, na.rm = FALSE)) |> 
    dplyr::mutate(
    building = dplyr::na_if(building, 0)
    ) |> 
  tidyr::pivot_longer(!best_country_name, names_to = "type", values_to = "label_n") |> 
  tidyr::drop_na()

countries_count <- 
  dplyr::left_join(
    countries_count,
    countries_labels,
    by = dplyr::join_by(best_country_name, type)
  ) |> 
    dplyr::arrange(dplyr::desc(label_n))

countries_count$best_country_name <- factor(
  countries_count$best_country_name, 
  levels = unique(countries_count$best_country_name) |> rev()
  )

countries_count <- 
  countries_count |> 
  dplyr::ungroup() |> 
  dplyr::filter(best_country_name != "") |> 
    dplyr::mutate(
        # best_country_name = forcats::fct_relevel(best_country_name, country_order)
        # best_country_name = forcats::fct_infreq(best_country_name) |> forcats::fct_rev()

        type = forcats::fct_relevel(
          type, 
          "transit", 
          "building"
          ) |> forcats::fct_rev()
        )

```

This month there were `r nrow(buildings_wide_df_short)` measurements of `r length(unique(buildings_wide_df_short$combined_id))` unique buildings.  

  @cr-ccplot  

`r describe_most_measured(most_measured)` 

There were measurements in `r nrow(countries_count)` separate countries. `r new_countries_sentence`  

 @cr-histco2plot 

Here is a graph that shows the distribution of all the CO~2~ measurements this month. The dashed red line shows the median which was `r median(mean_vals$ppmavg, na.rm = TRUE) |> round()` ppm. There are many measurements that we would consider good CO~2~ levels, however, you'll notice that about `r round((buildings_wide_df_short |> dplyr::filter(ppmavg > 1000) |> nrow()) / nrow(buildings_wide_df_short) * 100)` percent are over 1000 ppm, which really should be addressed.

:::{#cr-histco2plot}

```{r}
buildings_wide_df_short |> plot_histogram_co2()
```

:::


:::{#cr-ccplot}

```{r}
#| eval: false
#| include: false
countries_count <- 
buildings_wide_df_short |> 
    dplyr::group_by(country_code, type.x) |> 
    dplyr::count() |> 
    tidyr::drop_na() |> 
    sf::st_drop_geometry() |> 
    dplyr::ungroup()

# not yet done. need to give transit data a country col
countries_count_transit <- 
    transit_long_df_short |> 
    dplyr::group_by(country_code, type.x) |> 
    dplyr::summarise(n = dplyr::n_distinct(uid)) |> 
    tidyr::drop_na() |> 
    sf::st_drop_geometry()

countries_count <- 
  dplyr::bind_rows(countries_count, countries_count_transit) |> 
  dplyr::left_join(iso_3166_a2, by = dplyr::join_by(country_code == code)) |> 
  dplyr::mutate(
    type.x = factor(type.x, levels = c("building", "transit"))
    )

countries_count <- countries_count[order(countries_count$n, decreasing = TRUE),] |> 
  tidyr::drop_na()
```

```{r ccplot}
#| eval: false
#| include: false
#| warning: false
#| message: false

countries_count |> plot_countries_count()
  
```

```{r}
#| warning: false
#| error: false
#| message: false
#| fig.asp: 1.05
countries_count |> 
  tidyr::drop_na() |> 
  dplyr::rowwise() |> 
  dplyr::mutate(
    label_n = dplyr::if_else(
      type == "transit" && n < 5, 
      label_n + 16,
      label_n
      )
      ) |> 
  # dplyr::filter(n > 1) |> 
    ggplot2::ggplot(aes(x = best_country_name, y = n, fill = forcats::fct_rev(type))) +
    geom_col() +
    # ggrepel::geom_text_repel(
    geom_text(
      aes(y = label_n, label = n), 
      vjust = -0.5, 
      colour = "black",
      # min.segment.length = 1000,
      # direction = "y"
      # box.padding = 0.1
      # point.padding = 0.1
      ) +
    # scico::scale_fill_scico_d() +
    scale_fill_manual(values = c("#FFBB34", "#295059")) +
    labs(x = "Country", y = "Number of measurements") +
    tidyplots_theme() +
    theme(
      legend.title = element_blank(),
      axis.text.x = element_text(
      angle = 45, 
      # vjust = 0.5, 
      hjust=1)
      )
```

:::

  @cr-buildingtypes 

This graph shows the distribution of the most common building types in the month of `r start_date  |> lubridate::month(label = TRUE, abbr = FALSE)`. The dark bar in the middle of each box and whisker plot shows the median value for each category. The rest of the lines show the range of the distribution. Most of the values fall within each box. If you want more information about how to interpret this graph, watch [this video](https://youtu.be/b2C9I8HuCe4?si=73FKu7wSJr1rWwWt).

As is common, supermarkets tend to have higher CO~2~ values than other types of buildings. I've converted those CO~2~ values to the percentage of rebreathed air, which specifies how much of each breath you take has already been exhaled by someone else.

```{r buildingtypes1}
#| include: true
#| eval: false
#| warning: false
#| message: false
#| fig.asp: 1.2

plot_building_types_1(buildings_wide_df)
```

:::{#cr-buildingtypes}

```{r buildingtypes2}
#| include: true
#| eval: true
#| warning: false
#| message: false
#| fig.asp: 1.2

plot_building_types_2(buildings_long_df)
```

:::

```{r highlowbuildings}
#| warning: false
#| message: false
#| include: false 

buildings_long_df_med <- buildings_long_df |> 
  dplyr::filter(
    co2readings >= 410
  ) |> 
    dplyr::group_by(obs_number) |> 
    dplyr::mutate(
      median_co2 = median(co2readings),
      time_n = dplyr::row_number(),
      time_range = range01(time_n)
      # description_str = glue::glue("{nwrname} in {location_description}")
    ) |> 
      dplyr::ungroup()

highest_building <- buildings_long_df_med |> 
  dplyr::slice_max(order_by = median_co2) |> 
  sf::st_as_sf() |> 
  geocode_and_join() |> 
  add_all_town_cols(cols = cols) |> 
  dplyr::rowwise() |> 
  describe_location() |> 
  dplyr::mutate(description_str = glue::glue("{nwrname} in {location_description}"))

lowest_building <- buildings_long_df_med |> 
  dplyr::slice_min(order_by = median_co2) |> 
  sf::st_as_sf() |> 
  geocode_and_join() |> 
    add_all_town_cols(cols = cols) |> 
  dplyr::rowwise() |> 
  describe_location() |> 
  dplyr::mutate(description_str = glue::glue("{nwrname} in {location_description}"))
```

```{r highlowsentence}
#| warning: false
#| message: false
#| include: false 

lowest_sentence <- lowest_building |> 
  dplyr::group_by(obs_number) |> 
  dplyr::summarise(
    description_str = dplyr::first(description_str),
    median_co2 = dplyr::first(median_co2)
  ) |> 
    describe_buildings(measure = "lowest")

highest_sentence <- highest_building |> 
  dplyr::group_by(obs_number) |> 
  dplyr::summarise(
    description_str = dplyr::first(description_str),
    median_co2 = dplyr::first(median_co2)
  ) |> 
    describe_buildings(measure = "highest")

co2_threshold <- 500

buildings_under_threshold <- 
  buildings_long_df_med |>
  dplyr::filter(median_co2 < co2_threshold) |>
  sf::st_as_sf() |> 
  geocode_and_join() |> 
  add_all_town_cols(cols = cols) |> 
  dplyr::rowwise() |> 
  describe_location() |>
  dplyr::group_by(obs_number) |>
    dplyr::summarise(
      name = dplyr::first(nwrname),
      co2 = dplyr::first(median_co2),
      osmtag = dplyr::first(osmtag) |> stringr::str_to_sentence(),
      location_description = dplyr::first(location_description)
    ) |>
    dplyr::select(
      -obs_number
    ) 
  # list_buildings_under_threshold(co2_threshold)
```

Here is a graph of all the recordings that happened this month shown by the grey curves. I've highlighted the highest one. @cr-allcurves 

`r highest_sentence`  While this is incredibly high, it is important to realize that this is an outlier. The majority of measurements are much lower than this. There is a boxplot to the right of the graph which shows where the majority of measurements fall.  

`r lowest_sentence`
There were some measurements that were even lower than this, but we have removed them from this analysis. Generally outdoor CO~2~ levels don't go below 410 ppm, therefore we have removed any datapoints that are below 400 ppm. If your CO~2~ monitor consistently shows levels below 410 ppm while you are inside or outside, it is likely that your monitor needs recalibrating.

```{r}
#| warning: false
#| eval: false

create_co2_tibble(highest_building) |> 
plot_building_co2_vs_time()
```

```{r}
#| warning: false
#| eval: false

create_co2_tibble(lowest_building) |> 
  plot_building_co2_vs_time()

```

:::{#cr-allcurves}

```{r allcurves3}
#| warning: false
#| message: false
#| include: true 
#| fig.asp: 1.2
ylim_max <- max(highest_building$co2readings) + 200
plot_all_curves(sf::st_drop_geometry(buildings_long_df_med), ylim_max)
```

:::
:::

Here is a chart showing the `r nrow(buildings_under_threshold)` measurements that had a median CO~2~ value under `r co2_threshold`. Keep in mind that some of these are potentially miscalibrated sensors or erroneous recordings where the sensor was outside. However, it is important to celebrate the places that do in fact have well ventilated spaces.

```{r thresholdtable}
#| warning: false
#| message: false
#| include: true 

# add a column showing how many times a building has been on this list
# buildings_under_threshold |> 
#   knitr::kable(
#     col.names = c("Name", "Median CO<sup>2</sup>", "Building type", "Location")
#   )
buildings_under_threshold |> 
  sf::st_drop_geometry() |> 
gt_buildings_under_threshold()
```

## Trends over time

```{r animtrends}
#| warning: false
#| message: false
#| out.width: "100%"
bbox_buildings <- sf::st_bbox(buildings_wide_df)
anim <-
  buildings_wide_df |>
  dplyr::mutate(day = as.Date(date)) |>
  ggplot2::ggplot() +
  ggplot2::geom_sf(data = countries_sf, fill = "white") +
  ggplot2::geom_sf(aes(colour = ppmavg), size = 2) +
  gganimate::transition_time(day) +
  gganimate::enter_grow() +
  # gganimate::exit_shrink() +
  shadow_mark(past = TRUE, future = FALSE, alpha = 0.6 
  # color = "grey"
  ) +
  # xlim(0, 17) +
  # ylim(44.340868, 55.22535) +
  xlim(bbox_buildings[1] - 1, bbox_buildings[3] + 1) +
  ylim(bbox_buildings[2] - 1, bbox_buildings[4] + 1) +
  scale_color_viridis_c(
    name = "Mean CO2 ppm",
    breaks = c(420, 600, 800, 1200, 2000, 4000),
    transform = "log2",
    option = "turbo"
  ) +
  theme(
    plot.background = ggplot2::element_rect(fill = NA, colour = NA),
    plot.title = ggplot2::element_text(size = ggplot2::rel(1.5)),
    legend.background = ggplot2::element_rect(fill = NA, colour = NA),
    legend.key = ggplot2::element_rect(fill = NA, colour = NA),
    legend.key.width = unit(0.6, "lines"),
    legend.key.height = unit(1, "lines"),
    strip.background = ggplot2::element_rect(fill = "#cbd6dfff", colour = NA),
    panel.background = ggplot2::element_rect(fill = "#cbd6dfff", colour = NA),
    panel.border = ggplot2::element_rect(
      fill = NA,
      colour = "black",
      linewidth = 0.5
    ),
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank(),
    axis.ticks = ggplot2::element_line(colour = "black", linewidth = 0.25),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14)
  ) +
  ggtitle("{frame_time}")
frames_vec <- (length(unique(lubridate::date(buildings_wide_df$date)))/2) |> round(digits = 0)
animate(
  anim,
  nframes = frames_vec,
  driver = 'png',
  # quality = 40,
  # nframes = 260,
  fps = 25
) |> magick::image_trim()
# anim_save(here::here("data/derivative/animation.gif"), anim2)

```

The following are charts that are updated every month, but they reflect all data collected so far from the indoorco2 monitoring project (since April 2024). Over time, we should be able to see yearly trends where CO~2~ levels are higher in the Winter when shopkeepers close their windows to keep things warm and then lower CO~2~ levels when shopkeepers open their windows in the Summer.  

:::{.cr-section}

@cr-metweekall 

We can start to see trends like in this graph which shows CO~2~ against the week of the year. There are two relevant points you should know about the X axis, `Week of the year (meteorological)`, before moving on.  

1.  Datapoints are aggregated into weeks regardless of the year they are collected in, so some weeks were measured in `r lubridate::year(buildings_wide_df$date) |> unique() |> stringr::str_flatten_comma(last = ' and ')` but they would all show up in the same week number.  

2.  This accounts for the hemisphere in which the recording was collected. Since Winter in the Southern Hemisphere is June through August, while Winter in the Northern Hemisphere is December through February, we have adjusted the week numbers so that they line up meterologically. Essentially, a measurement collected in the Northern Hemisphere on the first of January would show up as week 1, however, a measurement collected in the Southern Hemisphere on the first of January would show up as week 27.

:::{#cr-metweekall}

```{r converthemisphere}
buildings_wide_df <- 
  buildings_wide_df |> 
  add_meteorological_week()
```

```{r}
#| include: false
#| eval: false
plot_buildings_boxplot_date_vs_co2(buildings_wide_df) 
```

```{r metweekall}
#| include: true
#| eval: true
#| warning: false
#| message: false

plot_buildings_week_co2(buildings_wide_df)
```

:::

@cr-metweektype

If we split the graph by the most popular building types, we can start to see some interesting trends. Supermarkets remain relatively high throughout the year with little variation while fast food, and chemists have quite a strong dip in CO~2~ levels during the Summer. This may be because most supermarkets keep their doors closed throughout the year and they tend to have larger buildings; conversely, chemists and fast food restaurants tend to be small to medium sized buildings which means that they can be very easily ventilated if they leave their front door open in the Summer. Restaurants have a very interesting trend here, the strong upward trend of the model at the end of the year is probably due to not enough measurements of restaurants yet rather that there being any meaningful conclusions. Over time we should hopefully see more stable trends show up.

:::{#cr-metweektype}

```{r metweektype}
#| include: true
#| eval: true
#| warning: false
#| message: false

plot_metweek_type(buildings_wide_df)
```

:::

```{r measurethisyear}
#| warning: false
#| message: false
#| include: false 
measurements_this_year <- 
  buildings_wide_df |> 
  dplyr::filter(dplyr::between(
        date,
        lubridate::today() - lubridate::weeks(52),
        lubridate::today()
    ))|>
       nrow() 
```

Here's a histogram showing how many measurements have been recorded each week since the start of the project. Over the last 12 months there have been `r measurements_this_year` building measurements which is `r round(measurements_this_year/12)` per month or `r round(measurements_this_year/52)` per week. @cr-allhist

:::{#cr-allhist}

```{r allhist}
#| include: true
#| eval: true
#| warning: false
#| message: false
plot_all_histogram(buildings_wide_df)
```

:::
:::

## Transit

```{r animtransit}
#| warning: false
#| message: false
#| out.width: "100%"
bbox_transit <- sf::st_bbox(transit_long_df_short)
anim <-
  transit_long_df_short |>
  dplyr::mutate(day = as.Date(date)) |>
  ggplot2::ggplot() +
  ggplot2::geom_sf(data = countries_sf, fill = "white") +
  ggplot2::geom_sf(aes(colour = co2Array), size = 2) +
  gganimate::transition_time(day) +
  gganimate::enter_grow() +
  # gganimate::exit_shrink() +
  shadow_mark(past = TRUE, future = FALSE, alpha = 0.6 
  # color = "grey"
  ) +
  # xlim(0, 17) +
  # ylim(44.340868, 55.22535) +
  xlim(bbox_transit[1] - 1, bbox_transit[3] + 1) +
  ylim(bbox_transit[2] - 1, bbox_transit[4] + 1) +
  scale_color_viridis_c(
    name = "Mean CO2 ppm",
    breaks = c(420, 600, 800, 1200, 2000, 4000),
    transform = "log2",
    option = "turbo"
  ) +
  theme(
    plot.background = ggplot2::element_rect(fill = NA, colour = NA),
    plot.title = ggplot2::element_text(size = ggplot2::rel(1.5)),
    legend.background = ggplot2::element_rect(fill = NA, colour = NA),
    legend.key = ggplot2::element_rect(fill = NA, colour = NA),
    legend.key.width = unit(0.6, "lines"),
    legend.key.height = unit(1, "lines"),
    strip.background = ggplot2::element_rect(fill = "#cbd6dfff", colour = NA),
    panel.background = ggplot2::element_rect(fill = "#cbd6dfff", colour = NA),
    panel.border = ggplot2::element_rect(
      fill = NA,
      colour = "black",
      linewidth = 0.5
    ),
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank(),
    axis.ticks = ggplot2::element_line(colour = "black", linewidth = 0.25),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14)
  ) +
  ggtitle("{frame_time}")
# frames_vec <- (length(unique(lubridate::date(transit_long_df_short$date)))/2) |> round(digits = 0)
animate(
  anim,
  nframes = 31,
  driver = 'png',
  # quality = 40,
  # nframes = 260,
  fps = 5
) |> magick::image_trim()
# anim_save(here::here("data/derivative/animation.gif"), anim2)

```

```{r mmtransit}
#| echo: false
#| warning: false
#| message: false
#| include: false 
most_measured_transit <- 
transit_long_df_short |> 
summarise_most_measured_transit()
  
```

:::{.cr-section}

This month there were `r length(unique(transit_long_df_short$uid))` measurements of `r length(unique(transit_long_df_short$line))` unique transit lines. `r describe_most_measured_transit(most_measured_transit)` This graph shows the number of transit recordings in each transit network during the last month. Keep in mind that this graph only shows networks with more than 2 transit recordings this month (there were quite a few with one or two). Transit recordings seem very popular in Vienna at the moment. @cr-transitcount

:::{#cr-transitcount}

```{r transitcount}
#| warning: false
#| message: false
#| include: false 
transit_count <- 
transit_long_df_short |> 
  count_transit()
```

```{r transitcountbar}
#| warning: false
#| message: false
#| include: false 
# transit_count |> 
#   plot_transit_count_bar()
```

:::

When we look at the distribution of CO~2~ measurements by the transit type this month we can see some patterns. Trains often have higher CO~2~ values than buses, subways and trams because they usually travel for longer distances between stations. This causes trains to rely more heavily on mechanical ventilation than buses, subways, and trams which open their doors at stations more frequently. @cr-transitmonthbox

:::{#cr-transitmonthbox}

```{r transitmonthbox}
#| include: true
#| eval: true
#| warning: false
#| message: false
transit_long_df_short |> 
  plot_transit_month_box()
```

:::

This trend can also be seen when we look at the distribution of each transit type on all the data from `r lubridate::year(buildings_wide_df$date) |> unique() |> stringr::str_flatten_comma(last = ' and ')`. @cr-transitallbox

:::{#cr-transitallbox}

```{r transitallbox}
#| include: true
#| eval: true
#| warning: false
#| message: false

transit_long_df |> 
  plot_transit_all_box()
```

:::


```{r transitmetweek}
#| warning: false
#| message: false
#| include: false 
transit_long_df <- 
  transit_long_df |> 
  add_meteorological_week()
```

```{r transitmetplot}
#| include: false
#| eval: false
#| warning: false
#| message: false

transit_long_df |> 
  plot_transit_met_week()
```

:::

That's all for this month! Check back soon for more updates.


If this was useful to you, please consider [supporting me](https://liberapay.com/samherniman/) so I can make more things like this. I would be incredibly grateful.  

<script src="https://liberapay.com/samherniman/widgets/button.js"></script>
<noscript><a href="https://liberapay.com/samherniman/donate"><img alt="Donate using Liberapay" src="https://liberapay.com/assets/widgets/donate.svg"></a></noscript>


### Some news

Recently Aurel Wünsch and I gave a talk about this project at Fluconf 2026. Check out the [recording here](https://www.youtube.com/live/60YwSH9g3Bg?si=RAdTgYvftXXevaIa), and the [companion website here](https://samherniman.github.io/Fluconf2026-indoorco2map/abstract.html).  

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/60YwSH9g3Bg?si=WsgFugFTD8ozkfF6" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>  


I was also interviewed for a podcast. You can listen to the [recording here](https://soundcloud.com/modulator-69529428/the-indoor-co2-map-community-science-in-the-pandemicene?si=c21857205e794f34998da835bf581d61&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing).

<iframe width="100%" height="166" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A2258686259&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true"></iframe><div style="font-size: 10px; color: #cccccc;line-break: anywhere;word-break: normal;overflow: hidden;white-space: nowrap;text-overflow: ellipsis; font-family: Interstate,Lucida Grande,Lucida Sans Unicode,Lucida Sans,Garuda,Verdana,Tahoma,sans-serif;font-weight: 100;"><a href="https://soundcloud.com/modulator-69529428" title="modulator" target="_blank" style="color: #cccccc; text-decoration: none;">modulator</a> · <a href="https://soundcloud.com/modulator-69529428/the-indoor-co2-map-community-science-in-the-pandemicene" title="The Indoor CO2 Map: Community Science in the Pandemicene" target="_blank" style="color: #cccccc; text-decoration: none;">The Indoor CO2 Map: Community Science in the Pandemicene</a></div>


### Some thanks

This work would not be possible without the hard work of all the contributors to [OpenStreetMap](https://www.openstreetmap.org/) and [indoorco2map](https://indoorco2map.com). If you would like to contribute to either of these projects, please visit their websites.
You can contribute to the indoorco2map by downloading the [Android app](https://play.google.com/store/apps/details?id=com.aurelwu.indoorairqualitycollector&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1) or [iOS app](https://apps.apple.com/us/app/indoorco2map-data-collector/id6504560820?itscg=30200&itsct=apps_box_badge&mttnsubad=6504560820) and connecting it to any one of the following CO~2~ sensors: [Aranet4](https://www.aranet.com/en/home/products/aranet4-home), [Airvalent](https://airvalent.com/), [AirSpot](https://airspothealth.com/products/airspot-copy) and [Inkbird IAM-T1](https://www.inkbird.com/products/smart-indoor-air-quality-monitor-iam-t1). You can also donate by contributing to the [indoorCO2map gofundme](https://www.gofundme.com/f/indoorco2mapcom-collectively-measuring-indoor-air-quality).  
I would also like to thank [Aurel Wünsch](https://github.com/AurelWu) who tirelessly works on the project as well as the other contributors to the project [ahunt](https://github.com/ahunt), [da5nsy](https://github.com/da5nsy), [paul-hammant](https://github.com/paul-hammant), and [samherniman](https://github.com/samherniman). 

Finally, many thanks go to the teams who work on the following software, which I used heavily. 

```{r}
#| warning: false
grateful::cite_packages(output = "paragraph", out.dir = ".")
```

All figures in this report are licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a><img src="https://mirrors.creativecommons.org/presskit/icons/cc.svg" alt="" style="max-width: 1em;max-height:1em;margin-left: .2em;"><img src="https://mirrors.creativecommons.org/presskit/icons/by.svg" alt="" style="max-width: 1em;max-height:1em;margin-left: .2em;"><img src="https://mirrors.creativecommons.org/presskit/icons/sa.svg" alt="" style="max-width: 1em;max-height:1em;margin-left: .2em;">. Please feel free to use and remix them and let me know if you do. I love to see my work being used elsewhere!  
